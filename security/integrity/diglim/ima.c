// SPDX-License-Identifier: GPL-2.0
/*
 * Copyright (C) 2021 Huawei Technologies Duesseldorf GmbH
 *
 * Author: Roberto Sassu <roberto.sassu@huawei.com>
 *
 * Functions to retrieve the integrity status from IMA.
 */

#include <linux/vmalloc.h>
#include <linux/module.h>
#include <linux/ima.h>

#include "diglim.h"

static int diglim_ima_get_info_file(struct file *file, u8 *digest,
				    size_t digest_len, enum hash_algo *algo,
				    u8 *actions)
{
	struct integrity_iint_cache *iint;
	struct inode *inode = file_inode(file);
	int ret = -ENOENT;

	iint = integrity_iint_find(inode);
	if (!iint)
		return ret;

	mutex_lock(&iint->mutex);
	/* File digest has not been calculated. */
	if (!(iint->flags & IMA_COLLECTED))
		goto out;

	ret = 0;

	if (iint->flags & IMA_MEASURED)
		*actions |= 1 << COMPACT_ACTION_IMA_MEASURED;

	if (iint->flags & IMA_APPRAISED)
		*actions |= 1 << COMPACT_ACTION_IMA_APPRAISED;

	if (test_bit(IMA_DIGSIG, &iint->atomic_flags))
		*actions |= 1 << COMPACT_ACTION_IMA_APPRAISED_DIGSIG;

	if (algo)
		*algo = iint->ima_hash->algo;
	if (digest)
		memcpy(digest, iint->ima_hash->digest, hash_digest_size[*algo]);
out:
	mutex_unlock(&iint->mutex);
	return ret;
}

static int diglim_ima_get_info_buffer(u8 *buffer, size_t buffer_len,
				      char *event_name, u8 *digest,
				      size_t digest_len, enum hash_algo *algo,
				      u8 *actions)
{
	int ret;

	ret = ima_measure_critical_data("diglim", event_name, buffer,
					buffer_len, false, digest, digest_len);
	if (ret < 0 && ret != -EEXIST)
		return -ENOENT;

	*algo = ima_get_current_hash_algo();

	if (!ret || ret == -EEXIST)
		*actions |= 1 << COMPACT_ACTION_IMA_MEASURED;

	return 0;
}

/**
 * diglim_ima_get_info - retrieve the integrity status of digest list from IMA
 * @file: file to retrieve the integrity status from
 * @buffer: buffer to retrieve the integrity status from (alternative to file)
 * @buffer_len: buffer length
 * @event_name: name of the event to be generated by IMA for buffer measurement
 * @digest: digest of the file or the buffer
 * @digest_len: digest length
 * @algo: digest algorithm
 * @actions: actions performed on the file or the buffer
 *
 * This function attempts to retrieve some information from the passed digest
 * list file or buffer: the digest, its algorithm, and the actions performed by
 * IMA.
 *
 * This function first attempts to retrieve the information from the file, and
 * if unsuccessful, attempts with the buffer.
 *
 * The caller must prevent writes to the file with deny_write_access() to ensure
 * that the file content the integrity status is retrieved from didn't change
 * since the time the buffer passed as argument was filled.
 *
 * Return: 0 if the information has been successfully retrieved, -ENOENT
 *         otherwise.
 */
int diglim_ima_get_info(struct file *file, u8 *buffer, size_t buffer_len,
			char *event_name, u8 *digest, size_t digest_len,
			enum hash_algo *algo, u8 *actions)
{
	int ret = -ENOENT;

	/* Ensure that the file is write-locked. */
	if (file && atomic_read(&file_inode(file)->i_writecount) >= 0)
		return -EINVAL;

	if (file) {
		ret = diglim_ima_get_info_file(file, digest, digest_len, algo,
					       actions);
		if (!ret && (*actions & (1 << COMPACT_ACTION_IMA_MEASURED)))
			return ret;
	}

	if (buffer) {
		ret = diglim_ima_get_info_buffer(buffer, buffer_len, event_name,
						 digest, digest_len, algo,
						 actions);
	}

	return ret;
}
