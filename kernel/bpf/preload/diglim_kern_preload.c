// SPDX-License-Identifier: GPL-2.0
/* THIS FILE IS AUTOGENERATED! */
#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
#include <linux/init.h>
#include <linux/module.h>
#include <linux/bpf_preload.h>
#include "diglim/diglim.lskel.h"

static struct bpf_link *exec_link;
static struct bpf_link *mmap_file_link;
static struct bpf_link *file_mprotect_link;
static struct bpf_link *file_open_link;
static struct bpf_map *digest_items_map;
static struct bpf_map *inode_storage_map_map;
static struct bpf_map *ringbuf_map;
static struct diglim_kern *skel;

static void free_objs_and_skel(void)
{
	if (!IS_ERR_OR_NULL(exec_link))
		bpf_link_put(exec_link);
	if (!IS_ERR_OR_NULL(mmap_file_link))
		bpf_link_put(mmap_file_link);
	if (!IS_ERR_OR_NULL(file_mprotect_link))
		bpf_link_put(file_mprotect_link);
	if (!IS_ERR_OR_NULL(file_open_link))
		bpf_link_put(file_open_link);
	if (!IS_ERR_OR_NULL(digest_items_map))
		bpf_map_put(digest_items_map);
	if (!IS_ERR_OR_NULL(inode_storage_map_map))
		bpf_map_put(inode_storage_map_map);
	if (!IS_ERR_OR_NULL(ringbuf_map))
		bpf_map_put(ringbuf_map);

	diglim_kern__destroy(skel);

	bpf_preload_set_ops("diglim_kern", THIS_MODULE, NULL);
}

static int preload(struct dentry *parent)
{
	int err;

	bpf_link_inc(exec_link);
	bpf_link_inc(mmap_file_link);
	bpf_link_inc(file_mprotect_link);
	bpf_link_inc(file_open_link);
	bpf_map_inc(digest_items_map);
	bpf_map_inc(inode_storage_map_map);
	bpf_map_inc(ringbuf_map);

	err = bpf_obj_do_pin_kernel(parent, "exec",
				    exec_link,
				    BPF_TYPE_LINK);
	if (err)
		goto undo;

	err = bpf_obj_do_pin_kernel(parent, "mmap_file",
				    mmap_file_link,
				    BPF_TYPE_LINK);
	if (err)
		goto undo;

	err = bpf_obj_do_pin_kernel(parent, "file_mprotect",
				    file_mprotect_link,
				    BPF_TYPE_LINK);
	if (err)
		goto undo;

	err = bpf_obj_do_pin_kernel(parent, "file_open",
				    file_open_link,
				    BPF_TYPE_LINK);
	if (err)
		goto undo;

	err = bpf_obj_do_pin_kernel(parent, "digest_items",
				    digest_items_map,
				    BPF_TYPE_MAP);
	if (err)
		goto undo;

	err = bpf_obj_do_pin_kernel(parent, "inode_storage_map",
				    inode_storage_map_map,
				    BPF_TYPE_MAP);
	if (err)
		goto undo;

	err = bpf_obj_do_pin_kernel(parent, "ringbuf",
				    ringbuf_map,
				    BPF_TYPE_MAP);
	if (err)
		goto undo;

	return 0;
undo:
	bpf_link_put(exec_link);
	bpf_link_put(mmap_file_link);
	bpf_link_put(file_mprotect_link);
	bpf_link_put(file_open_link);
	bpf_map_put(digest_items_map);
	bpf_map_put(inode_storage_map_map);
	bpf_map_put(ringbuf_map);
	return err;
}

static struct bpf_preload_ops ops = {
	.preload = preload,
	.owner = THIS_MODULE,
};

static int load_skel(void)
{
	int err = -ENOMEM;

	if (!bpf_preload_set_ops("diglim_kern", THIS_MODULE, &ops))
		return 0;

	skel = diglim_kern__open();
	if (!skel)
		goto out;

	err = diglim_kern__load(skel);
	if (err)
		goto out;

	err = diglim_kern__attach(skel);
	if (err)
		goto out;

	exec_link = bpf_link_get_from_fd(skel->links.exec_fd);
	if (IS_ERR(exec_link)) {
		err = PTR_ERR(exec_link);
		goto out;
	}

	mmap_file_link = bpf_link_get_from_fd(skel->links.mmap_file_fd);
	if (IS_ERR(mmap_file_link)) {
		err = PTR_ERR(mmap_file_link);
		goto out;
	}

	file_mprotect_link = bpf_link_get_from_fd(skel->links.file_mprotect_fd);
	if (IS_ERR(file_mprotect_link)) {
		err = PTR_ERR(file_mprotect_link);
		goto out;
	}

	file_open_link = bpf_link_get_from_fd(skel->links.file_open_fd);
	if (IS_ERR(file_open_link)) {
		err = PTR_ERR(file_open_link);
		goto out;
	}

	digest_items_map = bpf_map_get(skel->maps.digest_items.map_fd);
	if (IS_ERR(digest_items_map)) {
		err = PTR_ERR(digest_items_map);
		goto out;
	}

	inode_storage_map_map = bpf_map_get(skel->maps.inode_storage_map.map_fd);
	if (IS_ERR(inode_storage_map_map)) {
		err = PTR_ERR(inode_storage_map_map);
		goto out;
	}

	ringbuf_map = bpf_map_get(skel->maps.ringbuf.map_fd);
	if (IS_ERR(ringbuf_map)) {
		err = PTR_ERR(ringbuf_map);
		goto out;
	}

	/* Avoid taking over stdin/stdout/stderr of init process. Zeroing out
	 * makes skel_closenz() a no-op later in iterators_bpf__destroy().
	 */
	close_fd(skel->links.exec_fd);
	skel->links.exec_fd = 0;
	close_fd(skel->links.mmap_file_fd);
	skel->links.mmap_file_fd = 0;
	close_fd(skel->links.file_mprotect_fd);
	skel->links.file_mprotect_fd = 0;
	close_fd(skel->links.file_open_fd);
	skel->links.file_open_fd = 0;

	return 0;
out:
	free_objs_and_skel();
	return err;
}

late_initcall(load_skel);
module_exit(free_objs_and_skel);
MODULE_LICENSE("GPL");
